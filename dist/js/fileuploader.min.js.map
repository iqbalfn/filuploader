{"version":3,"sources":["../../src/js/fileuploader.js"],"sourcesContent":["/**\n * --------------------------------------------------------------------------\n * FileUploader (v0.1.0): fileuploader.js\n * Licensed under MIT (https://github.com/iqbalfn/fileuploader/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\n\nclass FileUploader {\n    constructor(options) {\n        this._queries  = options.queries    || {}\n        this._fields   = options.fields     || {}\n        this._files    = options.files      || {}\n        this._headers  = options.headers    || {}\n        this._url      = options.url\n        this._response = null\n        this._xhr      = null\n        this._chunks    = null\n        // {\n        //    chunk::int  Chunk index\n        //    chunks::int  Chunk total\n        //    options::obj {\n        //        minSize::int  Minimum size of file to chunk the upload\n        //        chunkSize:int  Each chunk file size to upload\n        //        test::func  Function to call to test chunk upload\n        //        after::func  Function to call right after last chunk\n        //        before::func  Function to call before the first chunk\n        //    }\n        // }\n\n        if(!Object.keys(this._files).length)\n            throw 'No file provided'\n\n        this._registerEvents(options)\n        this._buildUrl()\n        this._parseChunkOption(options)\n    }\n\n    // events callback\n    onChankUploaded(up, xhr, res, cb){ cb(true) }\n    onComplete(){}\n    onError(){}\n    onProgress(){}\n    onStart(){}\n    onSuccess(){}\n\n    // public\n\n    // actions\n\n    getResponse(){\n        return this._response\n    }\n\n    send(){\n        if(!this._chunks)\n            return this._sendSingle()\n        \n        this._chunks.options.before(this, cont => {\n            this._sendChunks()\n        })\n    }\n\n    // setter & adder\n    addField(name, value){\n        this._fields[name] = value\n    }\n\n    addFile(name, value){\n        this._files[name] = value\n    }\n\n    addHeader(name, value){\n        this._headers[name] = value\n    }\n\n    addQuery(name, value){\n        this._queries[name] = value\n    }\n\n    setUrl(url){\n        this._url = url\n    }\n\n    // getter\n    getUrl(){\n        return this._url\n    }\n\n    getField(name){\n        return this._fields[name]\n    }\n\n    getFields(){\n        return this._fields\n    }\n\n    getFile(name){\n        return this._files[name]\n    }\n\n    getFiles(){\n        return this._files\n    }\n\n    getHeader(name){\n        return this._headers[name]\n    }\n\n    getHeaders(){\n        return this._headers\n    }\n\n    getQuery(name){\n        return this._queries[name]\n    }\n\n    getQueries(){\n        return this._queries\n    }\n\n    // private\n\n    _buildUrl(){\n        let queries = []\n        let usign   = this._url.includes('?') ? '&' : '?'\n        for(let k in this._queries)\n            queries.push( this._qs(k) + '=' + this._qs(this._queries[k]))\n\n        if(queries.length)\n            this._url+= usign + queries\n    }\n\n    _parseChunkOption(options){\n        if(!options.chunks)\n            return\n\n        let file      = null\n        let config    = {}\n        let useChunk  = false\n        let defs   = {\n            chunkSize : 200000,\n            minSize   : 500000,\n            after(p,r,cb){ cb(r) },\n            before(up,cb){ cb(true) },\n            test(){ return true }\n        }\n\n        for(let k in defs)\n            config[k] = options.chunks[k] || defs[k]\n\n        for(let k in this._files){\n            file = this._files[k]\n\n            if(file.size < config.minSize)\n                continue\n\n            let proc = config.test(this, file, config)\n            if(!proc)\n                continue\n\n            useChunk = true\n            break\n        }\n\n        if(useChunk && Object.keys(this._files).length > 1)\n            throw 'Multiple file is not supported for chunk upload'\n\n        this._chunks = {\n            chunk   : 0,\n            chunks  : Math.ceil( file.size / config.chunkSize ),\n            options : config\n        }\n    }\n\n    _qs(str){\n        return encodeURIComponent(str)\n    }\n\n    _registerEvents(options){\n        let events = ['onChankUploaded', 'onComplete', 'onError', 'onProgress', 'onSuccess', 'onStart']\n        events.forEach(i => {\n            if(options[i])\n                this[i] = options[i]\n        })\n    }\n\n    _sendSingle(){\n        this.onStart(this)\n\n        this._upload(this._files, this._fields, (err,res) => {\n            this.onProgress(this, 100)\n            this.onComplete(this, this._xhr)\n            if(err)\n                return this.onError(this, this._xhr)\n            this.onSuccess(this, this._xhr, res)\n        })\n    }\n\n    _sendChunks(){\n        let file\n        let fkey\n        for(let k in this._files){\n            file = this._files[k]\n            fkey = k\n        }\n\n        let nextChunkIndex = this._chunks.chunk + 1\n\n        let config = this._chunks\n        let opts   = config.options\n\n        if(config.chunk)\n            this.onStart(this)\n\n        let chunkStart = config.chunk * opts.chunkSize\n        let chunkEnd   = chunkStart + opts.chunkSize\n        if(chunkEnd > file.size)\n            chunkEnd = file.size\n\n        let chunkFile  = file.slice( chunkStart, chunkEnd )\n        if(!chunkFile.size){\n            this.onComplete(this, this._xhr)\n            let res\n\n            try{\n                res = JSON.parse(this._response)\n            }catch(e){\n                res = this._response\n            }\n\n            return this._chunks.options.after(this, res, r => {\n                this.onSuccess(this, this._xhr, r)\n            })\n        }\n\n        let chunkFields    = this._fields\n        chunkFields.chunk  = this._chunks.chunk\n        chunkFields.chunks = this._chunks.chunks\n\n        let chunkProgress  = Math.round(nextChunkIndex / this._chunks.chunks * 100)\n        \n        let chunkForm = {}\n        chunkForm[fkey] = chunkFile\n\n        this._chunks.chunk = nextChunkIndex\n        this._upload(chunkForm, chunkFields, (err,res) => {\n            this.onProgress(this, chunkProgress)\n            \n            if(err)\n                return this.onError(this, this._xhr)\n\n            this.onChankUploaded(this, this._xhr, res, next => {\n                if(next === true)\n                    return setTimeout(() => this._sendChunks(), 100)\n                return this.onError(this, this._xhr)\n            })\n        })\n    }\n\n    _upload(files, fields, callback){\n        let formData = new FormData(),\n            xhr      = new XMLHttpRequest();\n\n        this._xhr    = xhr\n\n        for(let field in fields)\n            formData.append(field, fields[field])\n\n        for(let field in files)\n            formData.append(field, files[field], files[field].name)\n\n        xhr.open('POST', this._url, true);\n\n        xhr.onreadystatechange = e => {\n            if(xhr.readyState != 4)\n                return\n\n            this._response = xhr.responseText\n\n            if(xhr.status != 200)\n                return callback(xhr.status, 'Invalid server response')\n\n            let res = null\n            try{\n                res = JSON.parse(xhr.responseText)\n            }catch(e){\n                res = xhr.responseText\n            }\n\n            callback(0, res)\n        }\n\n        xhr.send(formData);\n    }\n}\n\nwindow.FileUploader = FileUploader\n\nexport default FileUploader"],"names":["FileUploader","options","this","_queries","queries","_fields","fields","_files","files","_headers","headers","_url","url","_response","_xhr","_chunks","Object","keys","length","_registerEvents","_buildUrl","_parseChunkOption","onChankUploaded","up","xhr","res","cb","onComplete","onError","onProgress","onStart","onSuccess","getResponse","send","_this","_sendSingle","before","cont","_sendChunks","addField","name","value","addFile","addHeader","addQuery","setUrl","getUrl","getField","getFields","getFile","getFiles","getHeader","getHeaders","getQuery","getQueries","k","usign","includes","push","_qs","chunks","file","config","useChunk","defs","chunkSize","minSize","after","p","r","test","size","chunk","Math","ceil","str","encodeURIComponent","_this2","forEach","i","_this3","_upload","err","fkey","_this4","nextChunkIndex","opts","chunkStart","chunkEnd","chunkFile","slice","JSON","parse","e","chunkFields","chunkProgress","round","chunkForm","next","setTimeout","callback","field","_this5","formData","FormData","XMLHttpRequest","append","open","onreadystatechange","readyState","responseText","status","window"],"mappings":"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"}